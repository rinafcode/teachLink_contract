/// Security vulnerability scanner for smart contracts
use std::collections::HashMap;
use std::fs;
use std::path::Path;

#[derive(Debug, Clone)]
pub enum VulnerabilityType {
    ReentrancyRisk,
    IntegerOverflow,
    UnauthorizedAccess,
    UncheckedReturn,
    TimestampDependence,
    GasLimitIssue,
}

#[derive(Debug)]
pub struct Vulnerability {
    pub vuln_type: VulnerabilityType,
    pub severity: Severity,
    pub location: String,
    pub description: String,
    pub recommendation: String,
}

#[derive(Debug, Clone, PartialEq)]
pub enum Severity {
    Critical,
    High,
    Medium,
    Low,
}

pub struct VulnerabilityScanner {
    vulnerabilities: Vec<Vulnerability>,
    patterns: HashMap<VulnerabilityType, Vec<String>>,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        let mut patterns = HashMap::new();
        
        // Reentrancy patterns
        patterns.insert(
            VulnerabilityType::ReentrancyRisk,
            vec![
                "transfer.*require".to_string(),
                "call.*balance".to_string(),
            ],
        );
        
        // Integer overflow patterns
        patterns.insert(
            VulnerabilityType::IntegerOverflow,
            vec![
                r"\+.*without.*check".to_string(),
                r"\*.*without.*check".to_string(),
            ],
        );
        
        // Unauthorized access patterns
        patterns.insert(
            VulnerabilityType::UnauthorizedAccess,
            vec![
                "pub fn.*without.*auth".to_string(),
                "fn.*no.*require_auth".to_string(),
            ],
        );

        Self {
            vulnerabilities: Vec::new(),
            patterns,
        }
    }

    pub fn scan_file(&mut self, file_path: &Path) -> Result<(), String> {
        let content = fs::read_to_string(file_path)
            .map_err(|e| format!("Failed to read file: {}", e))?;

        self.check_reentrancy(&content, file_path);
        self.check_integer_overflow(&content, file_path);
        self.check_access_control(&content, file_path);
        self.check_unchecked_returns(&content, file_path);
        self.check_timestamp_dependence(&content, file_path);

        Ok(())
    }

    fn check_reentrancy(&mut self, content: &str, file_path: &Path) {
        for (line_num, line) in content.lines().enumerate() {
            if line.contains("transfer") && !line.contains("// safe") {
                if self.has_state_change_after_transfer(content, line_num) {
                    self.vulnerabilities.push(Vulnerability {
                        vuln_type: VulnerabilityType::ReentrancyRisk,
                        severity: Severity::Critical,
                        location: format!("{}:{}", file_path.display(), line_num + 1),
                        description: "Potential reentrancy vulnerability: state changes after external call".to_string(),
                        recommendation: "Follow checks-effects-interactions pattern".to_string(),
                    });
                }
            }
        }
    }

    fn has_state_change_after_transfer(&self, content: &str, transfer_line: usize) -> bool {
        let lines: Vec<&str> = content.lines().collect();
        for i in (transfer_line + 1)..lines.len().min(transfer_line + 10) {
            if lines[i].contains("set(") || lines[i].contains("storage.") {
                return true;
            }
        }
        false
    }

    fn check_integer_overflow(&mut self, content: &str, file_path: &Path) {
        for (line_num, line) in content.lines().enumerate() {
            if (line.contains(" + ") || line.contains(" * ")) 
                && !line.contains("checked_add") 
                && !line.contains("checked_mul")
                && line.contains("i128") {
                self.vulnerabilities.push(Vulnerability {
                    vuln_type: VulnerabilityType::IntegerOverflow,
                    severity: Severity::High,
                    location: format!("{}:{}", file_path.display(), line_num + 1),
                    description: "Potential integer overflow without checked arithmetic".to_string(),
                    recommendation: "Use checked_add, checked_mul, or saturating operations".to_string(),
                });
            }
        }
    }

    fn check_access_control(&mut self, content: &str, file_path: &Path) {
        for (line_num, line) in content.lines().enumerate() {
            if line.trim().starts_with("pub fn") 
                && !line.contains("view")
                && !self.has_auth_check(content, line_num) {
                self.vulnerabilities.push(Vulnerability {
                    vuln_type: VulnerabilityType::UnauthorizedAccess,
                    severity: Severity::High,
                    location: format!("{}:{}", file_path.display(), line_num + 1),
                    description: "Public function without authorization check".to_string(),
                    recommendation: "Add require_auth or access control validation".to_string(),
                });
            }
        }
    }

    fn has_auth_check(&self, content: &str, fn_line: usize) -> bool {
        let lines: Vec<&str> = content.lines().collect();
        for i in fn_line..(fn_line + 15).min(lines.len()) {
            if lines[i].contains("require_auth") || lines[i].contains("check_admin") {
                return true;
            }
            if lines[i].trim().starts_with("fn ") || lines[i].trim().starts_with("pub fn") {
                break;
            }
        }
        false
    }

    fn check_unchecked_returns(&mut self, content: &str, file_path: &Path) {
        for (line_num, line) in content.lines().enumerate() {
            if line.contains(".call(") && !line.contains("?") && !line.contains("unwrap") {
                self.vulnerabilities.push(Vulnerability {
                    vuln_type: VulnerabilityType::UncheckedReturn,
                    severity: Severity::Medium,
                    location: format!("{}:{}", file_path.display(), line_num + 1),
                    description: "Unchecked return value from external call".to_string(),
                    recommendation: "Check return value or use ? operator".to_string(),
                });
            }
        }
    }

    fn check_timestamp_dependence(&mut self, content: &str, file_path: &Path) {
        for (line_num, line) in content.lines().enumerate() {
            if line.contains("timestamp()") && (line.contains("==") || line.contains("<") || line.contains(">")) {
                self.vulnerabilities.push(Vulnerability {
                    vuln_type: VulnerabilityType::TimestampDependence,
                    severity: Severity::Low,
                    location: format!("{}:{}", file_path.display(), line_num + 1),
                    description: "Logic depends on exact timestamp value".to_string(),
                    recommendation: "Use time ranges instead of exact comparisons".to_string(),
                });
            }
        }
    }

    pub fn get_vulnerabilities(&self) -> &[Vulnerability] {
        &self.vulnerabilities
    }

    pub fn get_critical_count(&self) -> usize {
        self.vulnerabilities.iter()
            .filter(|v| v.severity == Severity::Critical)
            .count()
    }

    pub fn get_high_count(&self) -> usize {
        self.vulnerabilities.iter()
            .filter(|v| v.severity == Severity::High)
            .count()
    }

    pub fn generate_report(&self) -> String {
        let mut report = String::from("# Security Vulnerability Report\n\n");
        
        report.push_str(&format!("Total vulnerabilities: {}\n", self.vulnerabilities.len()));
        report.push_str(&format!("Critical: {}\n", self.get_critical_count()));
        report.push_str(&format!("High: {}\n", self.get_high_count()));
        report.push_str("\n## Findings\n\n");

        for vuln in &self.vulnerabilities {
            report.push_str(&format!("### {:?} - {:?}\n", vuln.vuln_type, vuln.severity));
            report.push_str(&format!("Location: {}\n", vuln.location));
            report.push_str(&format!("Description: {}\n", vuln.description));
            report.push_str(&format!("Recommendation: {}\n\n", vuln.recommendation));
        }

        report
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_scanner_creation() {
        let scanner = VulnerabilityScanner::new();
        assert_eq!(scanner.vulnerabilities.len(), 0);
    }

    #[test]
    fn test_integer_overflow_detection() {
        let mut scanner = VulnerabilityScanner::new();
        let code = "let result: i128 = a + b;";
        scanner.check_integer_overflow(code, Path::new("test.rs"));
        assert!(scanner.get_vulnerabilities().len() > 0);
    }
}
